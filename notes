Psuedo code/ notes: 
Disclaimer: most of this is to help me think
	a lot of it probably might not be exactly implemented

================================1/8/15===============
command_stream
{
	char* buffer
	int iterator = 0 // index of last char we read
} 

make_command_stream( function_t getbyte, arg ):
	while no error in getting character:
		get a character
		resize buffer if needed
		store character in buffer

read_command:
	notes:
		read chars from stream into buffer
			stop at a valid point or syntax err
		when we can identify a full command
			create struct


	-talked about recursion and pipes

====1/9/15============================================
some notes on grammar
syntax:
	comment:
		- # allowable chars \n
	whitespace(spc):
		- [space, tab, newline] (check on newline?)
	word:
		-sequence of non spc chars
	simple command(sc):
		- word spc
		- word (excluding "if", "while", "until") spc sc
	compount command(cpd)
		- if cc then cc fi
		- if cc then cc else cc fi
		- while cc do cc done
		- until cc do cc done
	I/O redirect(red)
		- [empty]
		- < word
		- > word
		- < word > word
	command(c)
		- [sc, cpl, cpd, ss] red
	pipelines(pip): 
		- c
		- c | (pip) 
	complete command(cpl):
		- pip ;
		- pip \n
		- cpl cpl (maybe?)
	subshell(ss):
		- ( cpl )



example----------
ex)
echo "Stars"
i=0
while( i<=5 )
do
	j=0
    while( j<=i )
    do
     echo -n " *"
	j++
    done
    echo ""
	i++
done

note: this ex) is a little shitty cause of the vars, but treat "var=val" as a single word for now, also I left out spc's below, cause we'll maybe just eat them up when we build words and stuff

cpl
	cpl
		pip
			c
				sc
					word( excluding logical)
						echo
					word
						"Stars"
			red
				[empty]
	cpl
		pip
			c
				sc
					i=o
				red
					[empty]
	cpl
		pip
			c
				cpd
					while
					cpl
						pip
							c
								ss
									(
									cpl
										pip
											sc
												word
													i<=5
												red
													[empty]
									)
					do
						...
				red
					[empty]
	...


--------

===================1/10/15=================================================
very rough psuedocode

void append_to_token( char c, char* token )
{
	if token is non null
		if 


}

// puts a bunch of tokens in cstrings into the command stream
make_command_stream( function_t getbyte, getbyte_arg)
{
	char c
	int max_size = 10
	int cur_size = 0
	char* token = (char*) malloc( max_size ) // token is a cstring
	while( getting a byte into c returns valid )
	{
		switch c // might not actually be a switch statement later
		case [a-zA-Z0-9!%+,-./:@^_]
			if
				append to token, resize if needed
			break
		case [space or tab]			
			if prev was a space 
				ignore  ?
			else
				close the previous token
				put it in the stream
				make a new token
			break
// i think it's worth it to make \n a token ? cause it's significant in the syntax
		case [\n] 
			if the previous was \n ignore 
			// fall through
		case [;]
		case [|] 
		case [(]
		case [)]
		case [<]	
		case [>]
		case [#]
			close the prev token(put in  a \0 char)
			put it in the stream
			put c in a new token, close it
			put that in the stream too
			make a new token
			break		
	}

	return the stream
}

// before this is called, s is a collection of c strings, each of which is one of
// [ word ][ \n ][ ; ][ | ][ ( ][ ) ][ < ][ > ]
// I'm gonna go with a shift-reduce implementation for now
// works like this: shift a token into dostuff region, reduce dostuff region, repeat
read_command_stream( command_stream_t s )
{
	command* divider // points to second element (index 1) @ start
->	command* top // points to the top of command tree
	int scope = 0 // where we are in base[]
	command* base[ 5 ] // 5 for now, pointer to top of scope 
		// base[0] may replace top
	int cond = 0

	while divider isn't the end
	{
		// first look at new token to the left of divider that we just put on
		if ( word -> first char is a wordcharacter )
		{
			if ( it matches "if" "while" or "until" )
			{
				if ( immediate left of this token is ';' or '\n' or '|' or '(' )
				{
					make a new command
					point u.command[1] of the sequence command assoc. with
						the immediate left token at this command 
						( I think it'll be base )
					
					increment scope,
					make an appropriate new conditional command while, if, until
					zero out the u.command[] array
					put in base[scope] realloc if necesary 
						// maybe sep function
						
					// done?	
				}
				else
					// do nothing it's just a word then, fall through and continue
		 
			}
			else if ( matches "done", "fi )
			{
				if( prev. token is ';' '\n' )
				{
					cond = 0 ;
					maybe null out base[scope]
					decrement scope
				}
				else
					//do nothing, 'tis a word
			}
			else if ( matches "do" "then" "else")
			{
				continue
			}
			
			---- this is for nonlogical words
			if ( immediate left command is simple command )
			{
				concat this token onto the word of that command
			}
			else
			{
				make a new simple command
				put this token into the word of that command
				if( this isn't the first command )
					point base[scope] 's u.command[] at this by finding the first
						non null element in that array and putting this there
				else if ( this is the first command )
					point base[0] at this
			}
			----
		}
		


		move the divider right one command
	}	
	
}

reduce_stack( stack_t stack )
{
	command* top
	
}


===========1/11/15=========
REDO read_stream


read_command_stream( command_stream_t s )
{
	command* divider // points to second element (index 1) @ start
->	command* top // points to the top of command tree
	int scope = 0 // where we are in base[]
	command* base[ 5 ] // 5 for now, pointer to top of scope 
		// base[0] may replace top
	int cond = 0
	command* last
	
	while divider isn't the end
	{
		// first look at new token to the left of divider that we just put on
		if ( last == null )
		if ( word -> first char is a wordcharacter )
		{
			if ( it matches "if" "while" or "until" )
			{
				if ( immediate left of this token is ';' or '\n' or '|' or '(' )
				{
					make a new command
					point u.command[1] of the sequence command assoc. with
						the immediate left token at this command 
						( I think it'll be base )
					
					increment scope,
					make an appropriate new conditional command while, if, until
					zero out the u.command[] array
					put in base[scope] realloc if necesary 
						// maybe sep function
						
					// done?	
				}
				else
					// do nothing it's just a word then, fall through and continue
		 
			}
			else if ( matches "done", "fi )
			{
				if( prev. token is ';' '\n' )
				{
					cond = 0 ;
					maybe null out base[scope]
					decrement scope
				}
				else
					//do nothing, 'tis a word
			}
			else if ( matches "do" "then" "else")
			{
				continue
			}
			
			---- this is for nonlogical words
			if ( immediate left command is simple command )
			{
				concat this token onto the word of that command
			}
			else
			{
				make a new simple command
				put this token into the word of that command
				if( this isn't the first command )
					point base[scope] 's u.command[] at this by finding the first
						non null element in that array and putting this there
				else if ( this is the first command )
					point base[0] at this
			}
			----
		}
		


		move the divider right one command
	}	
	
}






